<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>The HTML5 Audit Handbook</title>
    <meta name="viewport" content="width=device-width" />
    <meta name="description" content="The HTML Audit Handbook: a technical guide to auditing, optimizing, and reviewing HTML code in accordance with modern standards, best practices for performance, and accessibility. Includes a checklist, examples, and references to MDN, and WHATWG." />
    <link rel="stylesheet" href="./css/styles.css" />
    <link rel="stylesheet" href="./css/prism.css" />
    <link rel="icon" type="./images/png" href="/images/favicon.png" />
    <link rel="canonical" href="https://docs.jbroldan.dev/html5-audit-handbook" />
  </head>
  <body>
    <header>
      <h1> "Contemporary Web Technical Auditing" &mdash; The Full Auditing Reference Handbook</h1>
      <p> A collection to audit modern websites &mdash; Last updated on 18. August 2025</p>
  <nav>
    <a href="#why">Why this handbook exist?</a>
    <a href="#download">Download PDF</a>
    <a href="#about">About the Author</a>
  </nav>

    </header>
    <div class="wrapper">
    <nav id="toc" class="sidebar">
      <h2>Table of Contents</h2>
      <!-- JS will insert links here -->
    </nav>
    <main>

      <header>
        <h1>Vol. 1: HTML5</h1>
      </header>


      
      <h2>Introduction</h2>
        <h3>What is HTML5?</h3>
          <p><em>HTML5</em> is an umbrella term that refers to the latest <a href="https://html.spec.whatwg.org/dev/" target="_blank">living standard of HTML</a>, maintained by WHATWG; as well as to a series of modern web technologies standards, such as the <a href="https://dom.spec.whatwg.org/" target="_blank">the DOM standard</a>, <a href="https://compat.spec.whatwg.org/" target="_blank">the compatibility standard</a>, or the <a href="https://fetch.spec.whatwg.org/" target="_blank">fetch standard.</a> </p>
        
        <h3>Background</h3>
          <p>HTML, or <i>Hypertext Markup Language</i>, is the World Wide Web's core markup language. First developed to write scientific documents at CERN in 1990, HTML now is a fundamental tool in how the World Wide Web operates and how internet browers &mdash;such as Chrome, Safari, or Firefox&mdash; read and display content.<br>Due to the collaborative and open source nature of HTML5 and the WHATWG project, HTML can be seen as inconsistent &mdash;which is a factually true statement&mdash;, and in this document we will try to help the Author overcome this inconvenience by providing a clear and consitent structure across the whole text. Also it is worth to add the adaptive nature of this declarative language, in which not only the standard was law, but also user behaviour forced browsers many times in the past to accept or recognize blatant syntax errors that were committed too often. </p>
      
        <h3>Audience</h3>
          <p>This book is intended to be used as a auditing guide of HTML5 best practices for consultors, freelancers, and agencies, that work in the area of web development. Clients often have a myriad of legacy systems, often poorly maintained, that don't follow the latest HTML5 practices and that would greatly benefit from it. This handbook is designed to be framework agnostic, as the auditing process must evaluate the end HTML document and DOM created by the browser, not the actual original code &mdash; which might be written in plain React, Vue, or any other framework. Chapters 2, 3, and 4 are mainly dedicated to best practices and advice on multiple topics that conform the HTML living standard. Chapters 5, 6 and 7 are specially focused on recognizing bad practices quickly, auditing an HTML documtent, and coming up with improvements for maintainability, compatibility, accessibility and SEO.</p>
        
        <h3>Extensibility</h3>
          <p>HTML allows the user to extend semantics and elements beyond the living standard, via the class attribute, custom elements, or using custom metadata content. Users have several tools for accessing data with HTML, such with <code class="language-markup">data-*=""</code> attributes, using <code class="language-markup">&lt;script type=""&gt;</code>, or via microdata using <code class="language-markup">itemscope=""</code> and <code class="language-markup">temprop=""</code> attributes. Authors can also extend APIs using JavaScript.<br>This means than in practice there are infinite possibilities in how to structure and organize an HTML document. However, that one <i>can</i> structure HTML as they wish, doesn't mean that one <i>should</i>. And that is exactly why this handbook exists.</p>
        
        <h3>Document Structure</h3>
          <p>A basic HTML document looks like this:</p>
          <pre><code class="language-markup">
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
              &lt;title&gt;Sample page&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
              &lt;h1&gt;Sample page&lt;/h1&gt;
              &lt;p&gt;This is a &lt;a href=&quot;demo.html&quot;&gt;simple&lt;/a&gt; sample.&lt;/p&gt;
              &lt;!-- this is a comment --&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </code></pre>
          <p><b>Note:</b> <code class="language-markup">&lt;!DOCTYPE html&gt;</code> does <b>not</b> represent an element, but a "DocumentType" node.</p>
          <p>HTML documents consist of a tree of elements and text. Each element is denoted in the source by a start tag and an end tag. The above example contains a number of semantic elements (<code class="language-markup"> &lt;head&gt;, &lt;body&gt;, &lt;title&gt;, &lt;h1&gt;</code>, and <code class="language-markup>">&lt;a&gt;</code>) which helps crawlers and text-assisted devices understand the meaning and structure of the content displayed. Certain elements are mandatory for any HTML document, such as &lt;head&gt; and &lt;body&gt;. The &lt;html&gt; element, which is the root element that contains the entire document, can be omitted. This is, however, <em>not</em> recommended, since it contains the language attribute. You should <em>always</em> include the &lt;html&gt; element in your document.</p>
          <p>Tags have to be nested such that elements are all completely within each other, without overlapping:</p>
            <pre><code class="language-markup">
              &lt;p&gt;This is &lt;em&gt;very &lt;strong&gt;wrong&lt;/em&gt;!&lt;/strong>&lt;/p&gt;
              &lt;p&gt;This &lt;em&gt;is &lt;strong&gt;correct&lt;/strong&gt;.&lt;/em&gt;&lt;/p&gt;
            </code></pre>
          <p>Elements can have attributes, which control how the elements work. Attributes are placed inside the start tag, and consist of a name and a value, separated by an "=" character. The attribute value can remain unquoted if it doesn't contain whitespaces or ", ', `, =, &lt;, or &gt;. Regardless, you should <em>always</em> quote your attribute values.</p>
        
        <h3>The DOM</h3>
          <p>Web browsers then parse this markup from the HTML document, turning it into a DOM (Document Object Model) tree. A DOM tree is an in-memory representation of a document.<br>DOM trees contain several kinds of nodes, in particular a <i>DocumentType</i> node, <i>Element</i> nodes, <i>Text</i> nodes, <i>Comment</i> nodes, and in some cases <i>ProcessingInstruction</i> nodes. The markup snippet at the top of this section would be turned into the following DOM tree:</p>
          <github-md>
            DOCTYPE html
            html lang="en"
            ├── head
            │   └── title
            │       └── "Sample page"
            └── body
                ├── h1
                │   └── "Sample page"
                ├──  p
                │    ├── "This is a "
                │    ├── a href="demo.html"
                │    │   └── "simple"
                │    └── " sample."
                └── <!-- this is a comment -->
          </github-md>
          <p>The document element of this tree is the html element, which is the element always found in that position in HTML documents. It contains two elements, head and body.</p>
          <p>This DOM tree can be manipulated from scripts in the page. Scripts (typically in JavaScript) are small programs that can be embedded using the script element or using event handler content attributes. Each element in the DOM tree is represented by an object, and these objects have APIs so that they can be manipulated. </p>
          <p>HTML documents represent a media-independent description of interactive content. HTML documents might be rendered to a screen, or through a speech synthesizer, or on a braille display. To influence exactly how such rendering takes place, authors can use a styling language such as CSS.</p>
        <h3>HTML Conformance Checker: v.Nu</h3>
          <p>HTML conformance checkers, also called validators, are tools that help you catch unintended mistakes in HTML, CSS, and SVG. Running a conformance checker as a first audit layer is highly recommended, since they are a lightweight and easy tool to detect what otherwise would pass unnoticed. Of all conformance checkers v.Nu (Nu Html Checker) is the only one that supports up to date HTML5 consistently.</p>
          <p>Authors can run v.Nu from the <a href="https://validator.w3.org/nu/" target="_blank">Official W3 Website</a>, or locally downloading it from <a href="https://github.com/validator/validator" target="_blank">GitHub</a>.</p>
        <h3>Security Basics</h3>
          <p>When HTML is used to create interactive sites, care needs to be taken to avoid introducing vulnerabilities through which attackers can compromise the integrity of the site itself or of the site's users.</p>
          <h4>Origins</h4>
            <p>The security model of the web is based on the concept of "origins", and correspondingly many of the potential attacks on the web involve cross-origin actions. Origins determine which content can interact with which—a core mechanism to stop malicious sites from accessing or messing with resources from other sites. An origin is, in the technical sense, a triple:</p>
            <code class="language-markup">
              origin = (scheme, host, port)
            </code>
            <p>Where:</p>
            <ul>
              <li>Scheme: The URI protocol (e.g. http, https, ftp)</li>
              <li>Host: The domain or IP (e.g. example.com, 192.0.2.5)</li>
              <li>Port: Explicit in the URL or the default for the scheme (80 for http, 443 for https)</li>
            </ul>
            <p>Two resources are same origin only if all three parts match exactly. Therefore, only when all three match exactly can two resources be considered "same origin".</p>
          <h4>Same Origin Policy (SOP)</h4>
            <p>The same-origin policy is a critical security mechanism that restricts how a document or script loaded by one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors. Under SOP, a script loaded from one origin can read or modify content only from resources with the exact same. </p>
            <p>For example, it prevents a malicious website on the Internet from running JS in a browser to read data from a third-party webmail service (which the user is signed into) or a company intranet (which is protected from direct access by the attacker by not having a public IP address) and relaying that data to the attacker.</p>
          <h4>Cross-site scripting (XSS)</h4>
            <p>Untrusted input (comments, URL parameters, third-party messages, etc.) must be validated before use and escaped before display. Without this, attackers could inject fake data, run malicious scripts on every page view (spreading the attack), or even wipe server data. Validation should be safelist-based because blocklists can't anticipate all future attack methods.</p>
            <p>Attackers can hide code in many ways, so safelist filters must be strict:</p>
              <ul>
                <li>Even for safe-looking elements like <code class="language-markup">&lt;img&gt;</code>, only allow specific attributes. Otherwise attackers could use <code class="language-markup">onload</code> to run JS scripts.</li>
                <li>If you accept URLs (e.g., in links), allow only specific schemes. Schemes like <code class="language-markup">javascript:</code> (and other custom ones) can execute malicious code.</li>
                <li>Block <code class="language-markup">&lt;base&gt;</code>. Don't allow users to insert a <code class="language-markup">&lt;base&gt;</code> element. <code class="language-markup">&lt;base&gt;</code> elements rewrite how relative URLs resolve, letting attackers hijack <code class="language-markup">&lt;script src&gt;</code> and redirect <code class="language-markup">&lt;form action&gt;</code> to a hostile site.</li>
              </ul>
          <h4>Cross-site request forgery (CSRF)</h4>
            <p>If your site lets logged-in users do state-changing actions (post, purchase, apply, etc.), another site can trick them into submitting those actions unknowingly (classic CSRF). HTML forms can submit to other origins, so a malicious page can auto-submit a form to your site using the victim's session.</p> 
            <p>An author should:</p>
              <ul>
                <li>Include user-specific hidden tokens in forms and validate them server-side.</li>
                <li>Check the <code class="language-markup">origin</code> header on state-changing requests; reject when it's missing or doesn't match your site.</li>
              </ul>
          <h4>Clickjacking</h4>
              <p>A hostile site can embed your page in an iframe and trick users into clicking your controls (e.g., via a reaction game that moves the hidden iframe under the cursor). This makes users perform actions they didn't intend. Any page that lets users perform actions they might not want to (purchases, settings changes, admin actions, etc.).</p>
              <p>If your page isn't meant to run in a frame, only enable the UI when you detect you're not framed (e.g., check <code class="language-markup">window === top</code> before activating controls).</p>
          <h4>Common pitfalls with APIs</h4>
              <p>JavaScript in browsers runs with <i>run-to-completion</i> semantics: once a script starts, nothing else (no new events, no further parsing) happens until it finishes. Meanwhile, HTML parsing is <em>incremental</em> and can pause to execute scripts, then resume. The consequence is timing: if you attach event handlers too late, an event could have already fired. To avoid missed events, either define handlers inline via HTML event attributes (so they exist as the element is parsed) or create the element and attach its handlers within the same synchronous script—because scripts run to completion, no events can slip in before your handler is registered.</p>
        <h3>Syntax Errors</h3>
          <p>HTML syntax is deliberately constrained to prevent unintuitive DOM results, reduce ambiguity, and keep implementations interoperable. Parsers may halt on errors rather than performing convoluted recovery; constructs whose recovery behavior breaks streaming parsers are simply invalid. The spec also avoids situations that would force XML-based tools to coerce the HTML infoset, preserving consistency across processing models.</p>
          <p>Rules prohibit patterns that cause disproportionate performance costs, rely on fragile historical quirks, or trigger known interoperability bugs in legacy user agents. Some restrictions exist purely for security (e.g., preventing encodings or patterns tied to XSS). Ambiguous markup, likely typos, and forms that could collide with future syntax are treated as errors to improve maintainability and forward-compatibility. For authors who prefer stricter discipline, conformance checkers can enforce conventions like always quoting attributes and including optional tags.</p>
          <p>Beyond raw syntax, the spec restricts element content models and attribute values to preserve clear semantics. It forbids nesting or role combinations that contradict the elements' meanings, and blocks combinations whose default rendering or behavior would confuse users (for example, nesting interactive controls inside each other). These constraints steer authors toward structures that match the language's intent and users' expectations.</p>
          <p>Additional limits exist to reduce author confusion and debugging pain: boolean attributes must be used correctly; duplicate IDs and similar pitfalls are disallowed because they lead to subtle script failures; and patterns with misleading parser behavior are flagged so authors don’t waste time chasing non-issues. Some rules simply simplify the language—removing redundant synonyms or edge cases—so it's easier to learn and teach.</p>
          <p>Finally, to ease (limited) HTML↔XML migration, certain attributes and namespace rules are constrained so documents behave similarly in both serializations. The spec also reserves parts of the language for future expansion and aligns with other standards (e.g., requiring valid media queries), ensuring today's documents won't block tomorrow's features and remain consistent with the broader web platform.</p>

      <h2>Structure and Semantics</h2>
        <h3>Semantic HTML</h3>
          <p>HTML is semantic <em>by design</em>. What this means is that the reason why W3C and browsers use HTML to display content, instead of any other markup language, is that HTML excels at semantic structure. Every element in HTML is designed with meaning in mind, to give crawlers and browsers the necessary information about what the content of an element is.</p>
          <p>To understand this, let's use as an example the most well known accessibility attribute, the <code class="language-markup">alt="This is an alternate description of an image."</code>, that specifies an alternate text for an image. Most authors and auditors are familiar with the fact that crawlers care a lot about this attribute, and that it is critical for SEO and accessibility. The reason is simple: Without the <code class="language-markup">alt=" "</code> attribute crawlers cannot "see" how the image looks like. However few are aware that this same logic applies for most content present in your HTML, as crawlers and text-reading devices <i>would like to know</i> what is the structure and the meaning of the content of the document.</p>
        <h3>Structure and Layouts</h3>
          <p>As we saw in Chapter 1, section 5, a HTML document includes a document type declaration and a <code class="language-markup">&lt;html&gt;</code> element at root, which contains nested on it the document head and document body. The head of the document is not visible to the viewer, but it is crucial, as it contains all the meta information, as well as icons for the browser tab and mobile home screen shortcut, and the behavior and styling of the content. We will cover all of the elements that can be nested inside the <code class="language-markup">&lt;head&gt;</code> element in Chapter 3.  </p>
          <p>The visible content of the document is located in the <code class="language-markup">&lt;body&gt;</code>. From this point onwards, HTML lets the user have complete freedom upon the structure of the visible content. One could, if desired, fill the content of the <code class="language-markup">&lt;body&gt;</code> element with a long uncomprehensible list of nested <code class="language-markup">&lt;div&gt;</code> elements. This is, however, highly undesirable, as it gives no information about the <em>meaning and structure</em> of the content to the crawlers and accessibility devices. </p>
          <p>More often than not, the nested elements inside <code class="language-markup">&lt;body&gt;</code> are very well defined. One can normally find at least these three elements nested inside:
            <ul>
              <li>A <code class="language-markup">&lt;header&gt;</code> element: The site header. It contains the header of the page. In contemporary web development this element tends to stay unchanged across multiple pages. Most of the time it carries the main navigation links and crucial site information.  </li>
              <li>A <code class="language-markup">&lt;main&gt;</code> element: There should be one <code class="language-markup">&lt;main&gt;</code> element per page. It identifies identifies the main content of the document.. If no other element is nested inside of <code class="language-markup">&lt;body&gt;</code>, then <code class="language-markup">&lt;main&gt;</code> should be the only element inside of it.</li>
              <li>A <code class="language-markup">&lt;footer&gt;</code> element: The site footer. It contains the footer of the page. In contemporary web development this element also tends to stay unchanged across multiple pages. It often carries navigation links and site information that are not present in the header site. </li>
            </ul>
            When nested inside <code class="language-markup">&lt;body&gt;</code>, all of these three elements are landmarks. Landmarks are special nodes in the AOM that carry semantinc meaning and give out key information about the structure of the document. They are indispensable for accessibility. We will dive deeper in what landmarks are and what is the AOM in the section 5 of the present Chapter.
            
          </p>
          <h4>Layouts</h4>  
            <p>As we saw previously, inside the &lt;body&gt; element we will always find the &lt;main&gt; section, which contains most of the content, as well as a number of other sections. Together they form the <em>layout</em> of the page.</p>
            <p>There are many different layouts, and most of the time the &lt;header&gt;, &lt;main&gt;, and &lt;footer&gt; layout provides a clean and simple layout, perfect for mobile screens and scrolling down. However, for content heavy sites like blogs or newspapers, or web apps with dashboards, we tend to see more often the <em>holy grail layout</em>, consisting of:</p> 
              <ul>
                <li>A <code class="language-markup">&lt;header&gt;</code> element: The site header. It contains the header of the page. In contemporary web development this element tends to stay unchanged across multiple pages. Most of the time it carries the main navigation links and crucial site information.  </li>
                <li>A <code class="language-markup">&lt;nav&gt;</code> element: </li>
                <li>A <code class="language-markup">&lt;main&gt;</code> element: There can be only one <code class="language-markup">&lt;main&gt;</code> element per page. It contains the majority of the page's content. If no other element is nested inside of <code class="language-markup">&lt;body&gt;</code>, then <code class="language-markup">&lt;main&gt;</code> must be the only element inside of it.</li>
                <li>A <code class="language-markup">&lt;footer&gt;</code> element: The site footer. It contains the footer of the page. In contemporary web development this element also tends to stay unchanged across multiple pages. It often carries navigation links and site information that are not present in the header site. </li>
                <li>An <code class="language-markup">&lt;aside&gt;</code> element: </li>              
              </ul>          
            <h4>Sections</h4>
            <p>According to the English Cambridge Dictionary, a section is <i>one of the parts that something is divided into.</i> We will use this definition to refer to the different parts in which authors can structure the content inside a document.</p>
          <h4>Section headings</h4>
        <h3>Structured Data</h3>
          <h4>JSON LD, Microdata, and RDFa</h4>
        <h3>On-Page SEO</h3>
        <h3>Beyond the DOM: CSSOM, and AOM</h3>

      <h2>HTML Elements and Syntax</h2>
        <h3>Document Metadata</h3>
        <h3>Sections</h3>
        <h3>Headings and Text</h3>
        <h3>Main Elements</h3>
          <h4>Grouping</h4>
          <h4>Links</h4>
          <h4>Navigation</h4>
          <h4>Tables</h4>
          <h4>Forms</h4>
          <h4>Graphics</h4>
          <h4>Multimedia</h4>
        <h3>Templates</h3>
        <h3>Custom Elements and Shadow DOM</h3>
        <h3>Other Elements</h3>
          <h4>Styling elements</h4>
          <h4>Inline text elements</h4>
          <h4>Full list of elements</h4>
        <h3>Attributes</h3>

      <h2>User Interaction and Web APIs</h2>
        <h3>PWAs</h3>

      <h2>Common Patterns & Pitfalls</h2>
        <h3>Metadata Keywords</h3>
        <h3><i>Divitis</i> and <i>Classitis</i></h3>
          
      <h2>Auditing</h2>
        <h3>Developer Tools</h3>
        <h3>Step by Step</h3>
        <h3>Audit Checklist</h3>

      <h2>Optimization</h2>
        <h3>DOM Structure</h3>
        <h3>Semantic HTML</h3>
        <h3>Image Handling</h3>
          <h4>Lazy loading</h4>
          <h4>Setting image size</h4>
        <h3>Script Loading</h3>
        <h3>Font Optimization</h3>
        <h3>Preloading</h3>

      

    </main>
    </div>

     <footer>
      <p>&copy;2025 Javier Bellido Roldan</p>
     </footer>

     <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js" defer></script>
     <script src="./js/prism.js"></script>
     <script src="./js/toc.js"></script>
  </body>
</html>
